\documentclass{report}
\usepackage[utf8]{inputenc}     % for éô
\usepackage[english]{babel}     % for proper word breaking at line ends
\usepackage[a4paper, left=1.5in, right=1.5in, top=1.5in, bottom=1.5in]{geometry}
% for page size and margin settings
\usepackage{graphicx}           % for ?
\usepackage{amsmath,amssymb}    % for better equations
\usepackage{amsthm}             % for better theorem styles
\usepackage{mathtools}          % for greek math symbol formatting
\usepackage{varwidth}
\usepackage{enumitem}           % for control of 'enumerate' numbering
\usepackage{listings}           % for control of 'itemize' spacing
\usepackage{todonotes}          % for clear TODO notes
\usepackage{hyperref}           % page numbers and '\ref's become clickable
\usepackage{pgfplots}
\usepackage{caption}
\usepackage{parskip}
\usepackage{makecell}
\usepackage{tabularx}
\usepackage{url}

% \pgfplotsset{width=10cm,compat=1.9}


% Listing style

%% Package for colors.
\usepackage{xcolor}
%% Useful colors
\definecolor{blue}{RGB}{0,0,255}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.973,0.906}
\definecolor{mygray}{gray}{0.96}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{js}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  sensitive=true
}

%% Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{mygray},
%commentstyle=\color{codegreen},
%keywordstyle=\color{magenta},
%numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
%   numbers=left,                    
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
% "mystyle" code listing set
\lstset{style=mystyle}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SET TITLE PAGE VALUES HERE %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             ||               %
%             ||               %
%             \/               %

\newcommand{\thesistitle}{Integrating secure authenticated video calling into PubHubs}
\newcommand{\thesissubtitle}{A design for authenticated video calling}
\newcommand\thesisauthorfirst{Julian van der Horst \\ s1015357}
\newcommand\thesisauthorsecond{\null}
\newcommand\thesissupervisorfirst{Bart Jacobs}
\newcommand\thesissupervisorsecond{Omar Javed}
\newcommand\thesissecondreaderfirst{TBA}
\newcommand\thesissecondreadersecond{Bram Westerbaan}
\newcommand\thesisdate{February 2024}


%% FOR PDF METADATA
\title{\thesistitle}
\author{\thesisauthorfirst\space\thesisauthorsecond}
\date{\thesisdate}

%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\begin{titlepage}
\thispagestyle{empty}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\center
\textsc{\Large Radboud University Nijmegen}\\[.7cm]
\includegraphics[width=25mm]{img/in_dei_nomine_feliciter}\\[.5cm]
\textsc{Faculty of Science}\\[0.5cm]

\HRule \\[0.4cm]
{ \huge \bfseries \thesistitle}\\[0.1cm]
\textsc{\thesissubtitle}\\
\HRule \\[.5cm]
\textsc{\large Thesis M.Sc. Computing Science}\\[.5cm]

\begin{minipage}{0.4\textwidth}
    \begin{flushleft}
        \large
        \emph{Author:}\\
        \thesisauthorfirst\space \textsc{\thesisauthorsecond}
    \end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
    \begin{flushright}
        \large
        \emph{Supervisor:} \\
        \thesissupervisorfirst  \\[1em]
        \emph{Daily supervisor:} \\
        \thesissupervisorsecond \\[1em]
        \emph{Second reader:} \\
        \thesissecondreadersecond \\[1em]
    \end{flushright}
\end{minipage}\\[4cm]
\vfill
{\large \thesisdate}
\end{titlepage}
\newpage
\section*{Abstract}
As online communication becomes increasingly integral to remote work and collaboration, the need for secure and
privacy-conscious platforms has never been greater. While mainstream platforms like Microsoft Teams and Slack
dominate, they often compromise user privacy. PubHubs offers a  privacy-first alternative, built on a decentralized
network of independent hubs with cryptographic safeguards to ensure user control over data. However, the lack of
integrated video conferencing functionality limits its usability in today’s virtual environment. This research
addresses this gap by designing and implementing an authenticated video conferencing solution for PubHubs. The
solution aims to be secure, privacy-friendly, and scalable, in alignment with PubHubs’ core principles.


\tableofcontents
\chapter{Introduction}
In today's digital landscape, privacy and security in online communication are more critical than ever.
The COVID-19 pandemic accelerated a shift towards remote work and online communication, which for many people is here to stay.
The online communication is mostly done on platforms like Microsoft Teams, Slack, or Discord.
However, these platforms often fall short in protecting user privacy, which is a big concern when discussing sensitive
information.

The video conferencing platform Zoom was set up for easy of use. This opened the door for many security and privacy
issues. For example, the platform allowed anyone to join a call if they knew (or guessed) the meeting ID. This
allowed for so-called Zoom-bombing, where uninvited guests would join a call and disrupt the meeting \cite{ling_first_2021}.
Another famous example is the case of Russian spies who listened in on a military conference call \cite{
schmitz_germany_2024}. The underlying issue is the lack of proper authentication. This is a problem that is not
unique to Zoom, but is present in many video conferencing platforms.

PubHubs is an alternative community platform that puts public values first.
PubHubs is organized as a network of independent hubs, with a shared single-sign-on.
Using cryptographic techniques, PubHubs ensures that users maintain control over their identity while preserving
accountability and verifiability. PubHubs is still in development and currently only supports messaging-based
communication within hubs, including the sharing of images, videos, and other media. These messages are being
sent using the Matrix protocol, which is a decentralized communication protocol that allows for secure and private
communication. PubHubs functions as a Matrix client with additional features such as secured rooms, which we discuss
further in \autoref{sec:pubhubs}.

The lack of video conferencing functionality in PubHubs limits its utility in the real world, where face-to-face
virtual interactions are essential. Currently, users must rely on external video conferencing tools, which compromises
two aspects of privacy. The external platform itself may collect and analyze user data, while pseudonymous users may
unintentionally reveal their real name or email address to other participants by remaining logged into these third-party
platforms. Both these aspects undermine the core privacy values of PubHubs. Even if users take precautions to remain
anonymous, the authentication of the other participants remains a concern. Using these external platforms, there is no
way to verify that the person on the other end of the call is the same user from the PubHubs platform.

In this research, we design and implement an authenticated video conferencing solution for PubHubs. This
solution should be secure, privacy-friendly, and scalable. We define key requirements in terms of privacy,
security, and usability, aligned with PubHubs’ principles. Based on these requirements, we design and implement
a prototype of the video conferencing solution. We evaluate the prototype against the established
criteria (discussed in \autoref{chap:requirements}). The prototype serves as a foundation for future development.
Additionally, this research provides insights into the possibilities and challenges of integrating video
conferencing into PubHubs.

\chapter{Background}
We assess the current state of PubHubs as well as the different frameworks and technologies that we will use in
our design. This is needed to fully understand the requirements and design of the video conferencing solution. We
also discuss what precisely we mean with video conferencing and what the different options are for video
conferencing.

\section{Video conferencing}
Video conferencing systems have been around since the 60s and 70s, when NASA used these systems to communicate with
astronauts on space flights. They made their appearance in many science fiction works, where it seems like a far-off
future. However, in the last decade, video conferencing has become a standard tool for many businesses and individuals.
Popularity increased dramatically during the COVID-19 pandemic, when there was a big need for remote work.
Immediately, services like Zoom \cite{noauthor_one_nodate} and Microsoft Teams  \cite{noauthor_microsoft_nodate} gained
widespread adoption. These tools allowed video conferencing between different remote locations in real-time.
However, these tools are not always privacy-friendly or authenticated and are mostly set up for convenience and ease
of use \cite{gauthier_dynamic_2021}.

While some of these video conferencing services may include end-to-end encryption, most do not \cite{gauthier_dynamic_2021}.
With end-to-end encryption, the data is encrypted on the client side and only is decrypted on the receiver's client
side. This way, the server does not have access to the video and audio data. Furthermore,
these services often lack authenticated video conferencing. Authenticated video conferencing is a video
call where you can verify that the person you are calling is who they say they are.
On online platforms, you can pretend to be anyone you want. It is even rather simple to digitally
modify your voice or face. This has been done in the past by North Korean hackers to infiltrate a US organization \cite{
noauthor_how_nodate}. When we consider the situation of an online consultation with a medical professional,
you want to be sure that you are actually calling a licensed doctor. This is where authenticated video conferencing comes in.

If we look at video conferencing from an architectural perspective, we see that there are multiple conferencing
architectures. For this research, we will only distinguish three types. These types will most likely be different types
of video conferencing that will occur on the PubHubs platform. We distinguish these types because
they all have certain properties that yield different requirements for the video conferencing solution. 

\newpage
The three types are:
\begin{itemize}
\item Person-to-person (one-on-one)
\item Person-to-person (multiple people)
\item Speaker-to-audience
\end{itemize}

Where in one-on-one we only need to send and receive data to one other person, when we are in a
group we need to send and receive data to each member in a call. On the contrary, with speaker-to-audience, we do
not have connections between the individual audience members. The first and second setup are more in line with what
we expect the users of PubHubs to use video conferencing for, so we will focus on them in this research.

\begin{figure}[!hbt]
\centering
\includegraphics[width=0.7\textwidth]{img/three-types}
\caption{The three types of video conferencing.}
\label{fig:three-types-video-conferencing}
\end{figure}

With video conferencing, people need to send and receive video streams, and we want to do this ideally in real-time.
A standard for that is WebRTC, and it is now widely supported in browsers (97.77\% of browser versions used) \cite{
noauthor_webrtc_nodate}. WebRTC is both a protocol and an API that can be used for many things, including video and audio communication. In our
implementation, we will use WebRTC to send video and audio streams. These streams eventually need to arrive at
the other participants in the call. However, it can take many different paths to get there depending on the setup of
the network.

The first option is to send the video and audio streams peer-to-peer (P2P). This means that the people in
the call send their stream to every other person in the call. This option does not need a central server to manage or
distribute the audio and video stream, ensuring that the server has no extra load. The server simply
facilitates the call setup. However, with every extra participant, every user needs to send/receive more and more
data. With every new user, every client needs to use more resources and at some point, a bottleneck is
reached, and loss of data will occur. This is a very privacy-friendly method since the server has no access to the
video conferencing data being sent and the users have full autonomy to choose who can receive their video data.
However, due to the limited number of participants, this solution is not feasible.

Another option would be to have a Multipoint Control Unit (MCU). An MCU takes in many media streams, possibly
converts it to another format, and combines these streams into one media stream. This makes it so that it can work
very well with legacy systems. For example, this would allow a participant to call in from a phone
connection while the other participant is using a desktop application. The MCU has to encode and decode all the
incoming media signals, which makes it costly for the server owner at large scale, since this is a computationally intensive
task. From a security and privacy perspective, this solution is also not ideal, since the server has access to all the
unencrypted video and audio data, which would mean that the server could potentially listen in or even impersonate
someone on the call.

Lastly, we have an architecture with a Selective Forwarding Unit (SFU). An SFU behaves in a way like a switch where it
would selectively forward streams between clients, it does not interact with the video streams so it would work
similarly with encrypted and unencrypted data.  In \autoref{fig:three-options-video-conferencing} we have
illustrated this with the tangent line on the data flows, indicating that the flow goes through the server, but
the unencrypted payload does not. From a user perspective, we only need to talk to one server, and we
send and receive all our data through that server.  The server simply forwards and thus does not distinguish data
coming from a user or another SFU, which in turn means that we can have multiple SFUs working together to relieve
the load. This can increase the scalability of the system in terms of the number of participants or the quality of the streams when
participants are geographically far apart. An SFU provides a compelling balance of scalability and privacy, which is
why we will use this in our implementation.

\begin{figure}[!hbt]
\centering
\includegraphics[width=\textwidth]{img/thesisDPD}
\caption{The three network topologies}
\label{fig:three-options-video-conferencing}
\end{figure}

PubHubs for now is only a web-based app, and we will only focus on the web-based video conferencing solutions. This means
that we do not need the legacy support that an MCU provides. We also do not want to have the server have access to the
video and audio data. This leaves us with the SFU and P2P. Since we want to have a scalable solution, we will use
the SFU.
Perhaps to save on server bandwidth and to have a more privacy-friendly solution, we can use a P2P network for one-on-one
conferencing. This is out-of-scope for this research but could be an interesting bandwidth saving feature for PubHubs.

\section{PubHubs}\label{sec:pubhubs}
PubHubs, short for Public Hubs, is an alternative community platform that puts public values first
\cite{jacobs_pubhubs_2023}. Unlike mainstream social media platforms like Instagram or Twitter that focus on
individual broadcasting, PubHubs emulates offline social dynamics by centering interactions within smaller,
community-based hubs. The reasoning
behind that is that this behavior closely resembles offline human interaction, where humans have small groups of
friends and collaborators with whom they interact. Social media now is very unnatural, where if people engage with a
platform, their posts are broadcasted into the whole world and are for everyone to see.

PubHubs is organized as a network of independent hubs, with a shared single-sign-on. Conversations take place in
local hubs (and not globally) and the associated (conversation) data is managed decentrally, within each hub
\cite{jacobs_pubhubs_2023}. The main idea of PubHubs is to allow pseudonymity while maintaining both accountability
and the ability to verify certain attributes of the user. Privacy is one of the core values of PubHubs, which can be
seen in how it handles identity management.

PubHubs consists of a central server (PubHubs central or \textit{PHC}), the Transcryptor (\textit{TS}) and multiple
hubs.
When a user registers, they register at PubHubs central using Yivi (formerly IRMA)\cite{alpar_irma_nodate} by disclosing
certain attributes. When the attributes are verified, the user is assigned a global identity by \textit{PHC}.
This global identity (pseudonym) is an Elgamal encryption of the user identity, which no single entity within PubHubs
can decrypt, but if the \textit{PHC} and the \textit{TS} work together they can. In each hub, the user will have a
local identity, which is derived from the global pseudonym. This local identity is created by multiplying the
global pseudonym with a hub specific 'pseudonymization' factor, which is only known by the \textit{TS}. This is set
up in such a way that \textit{PHC} does not learn to which hub the user is going, while \textit{TS} does not learn
who is visiting the hub. This way the user can be pseudonymous within the hub, and even across hubs, but whenever the
\textit{PHC} and the \textit{TS} work together they can identify the user, for instance when the user is misbehaving.

In PubHubs all communication is done via Matrix. Matrix is an open-source network for secure, decentralized
communication \cite{noauthor_matrixorg_nodate}, which will be explained in \autoref{sec:matrix}. PubHubs can be considered a
layer on top of Matrix, which handles the identity management and adds some extra features like the ability to have
secured rooms.

Secured rooms are rooms in which a user can only enter if one or more attributes are disclosed. For example, a hub can
require that a user lives in a specific municipality before they can enter a room. The hub can request an attribute
using Yivi, after which the hub can cryptographically verify that the user has the attribute. The hub can do this
without knowing the actual value of the attribute. Staying with the example of the municipality, the hub can
verify that the user lives in that municipality without knowing the actual address of the user. This is a powerful
feature of PubHubs, which can be used for many use cases.

In PubHubs the hubs are intended to be run by different organizations which typically have a public function, such as
local governments, schools, libraries, or hospitals.
These hubs can have different community rules or even have different features.
To allow this, PubHubs has a strong divide between PubHubs central and the different hubs.
This division is also made in the client, where there is a distinction between the global client and the (multiple) hub clients.

The global client enables a user to log in and then go from a hub to another hub without further authentication. It is
the interface that you see when you visit the PubHubs website. Once you enter a hub, the global client loads the hub
client in an Iframe. This prohibits the global client's JavaScript from interacting with the hub client.
The hub client is the client that the hub itself deploys. The hubs have full control over their own
hub client. They can control the layout, the features, and the look and feel of the hub client.

In the code base, there is also a clear distinction between the global client and the hub client. They
are separate code bases, which are built and deployed separately. These clients are isolated from each other.
However, there is a way to communicate between the global client and the hub client. This is used only to let the
hub client know certain settings which are stored in the global client, for example, whether the user prefers a
light or dark theme.

\section{Matrix and Element call}\label{sec:matrix}
As mentioned previously, PubHubs is built upon Matrix. Matrix is an open-source network for secure, decentralized
communication. It is built on an open standard, which means that anyone can build a client or server that is fully
compatible with the Matrix protocol. Users can even make proposals to change the protocol, which can then be voted on
by the community. This protocol is continuously changing depending on the use cases of their users. These changes
are then implemented in the multiple server implementations of the protocol. The most well-known server
implementation is Synapse \cite{noauthor_element-hqsynapse_nodate}, which is the reference implementation of the
Matrix protocol and is also used by PubHubs.

PubHubs can be considered a layer on top of Matrix, which handles the identity management and adds some extra features.
A hub will have to deploy a Matrix home server, in this case synapse, and their hub client. This also means that you can
access PubHubs hubs using any Matrix client, with the downside that PubHubs specific features are not available in
all clients, such as requesting attributes using Yivi. Matrix is the fundamental layer of PubHubs, and it is
important to keep in mind when designing and implementing new features. When designing the video conferencing
solution, we will have to keep in mind the Matrix protocol and only deviate from it when absolutely necessary.

It is important to note that when talking about Matrix, it sometimes refers to the specification and sometimes to the
reference implementation. In this research, we will mostly talk about the specification and not the implementation. These
should match, but from time to time, there are differences. For instance, when a new feature is in the specification
but not yet implemented in the reference implementation. We are mostly interested in proposal 3401 \cite{
noauthor_matrix-spec-proposalsproposals3401-group-voipmd_nodate}, since here Matrix added functionality for video conferencing.
This proposal can be applied to all the above-mentioned server setups and describes a protocol for video conferencing.

The same team that builds Matrix is also building Element \cite{noauthor_element_nodate}, which is an open-source Matrix client.
A new feature was added in 2022 \cite{noauthor_introducing_2022} to Element called Element call, which serves as an
example implementation of proposal 3401 \cite{noauthor_matrix-spec-proposalsproposals3401-group-voipmd_nodate}.
The Element team started by using peer-to-peer video conferencing, since this more closely resembled the decentralized
infrastructure of Matrix. However, this turned out to not be the best solution since it allowed for a maximum of 7
participants and video conferencing required numerous computer resources from participants \cite{heese_lab3_nodate}.
Recently, the Element team have released a new version that makes use of an open-source SFU called Livekit
\cite{noauthor_livekit_nodate}.

We use this new Livekit implementation as a guide during our research; however, we evaluate all the different
choices made for Element call and deviate from them based on the requirements of PubHubs. When using Livekit we can
easily implement features like noise suppression or video simulcast (Sending multiple video streams with different
qualities, to dynamically choose the quality according to a user's internet connection).

When you join a Livekit video call, you actually join a Livekit room. These Livekit rooms can be different from the
rooms in PubHubs. I.e., within one PubHubs room, in theory there could be multiple Livekit rooms. However, we will
directly map PubHubs rooms to Livekit rooms for ease of implementation, and having multiple Livekit rooms in one
PubHubs room does not offer any additional security or privacy benefits. That means that when you start a
call in a PubHubs room, you join a Livekit room with the same name as the PubHubs room. It also means that this solution
will only allow one call per PubHubs room. We will discuss the technical details in \autoref{sec:server-setup}.

\chapter{Requirements}\label{chap:requirements}
We first discuss the different requirements that we have for a video conferencing setup in PubHubs. We discuss
these requirements from a privacy and security perspective, but also from a usability perspective. We will also
discuss the (software) design requirements that we have for the video conferencing solution.

\section{Confidentiality}
Confidentiality is the principle that information is not made available or disclosed to unauthorized individuals,
entities, or processes. In the context of video conferencing, this means that the video and audio data should only
be available to the participants in the call. Even the server should not have access to the video and audio data. We
can achieve this by having end-to-end encryption between the participants. The data is encrypted on the client side and
only decrypted by the receiver on their client side. If the server does not know the encryption keys, then it will
not have access to the video and audio data.

This end-to-end encryption should be secure as well as being fast, since the data is real-time, and we want as little
latency as possible. If the encryption and decryption are computationally expensive, the latency will increase,
which will result in a poor user experience. We also do not want huge system requirements for the clients, since
PubHubs should be accessible to everyone.

Some conversations might be sensitive, so we want to make sure that only the users currently in the call can
decrypt the video and audio data. We do not want new users to be able to decrypt the video and audio data from
before they joined the call. This is called forward secrecy. We want to cryptographically ensure that
the video and audio data is available only to the participants that the user can see in the call.

\section{Integrity}
Integrity is the principle that information is protected from unauthorized modification. For video conferencing, transmission integrity
is crucial. Transmission integrity ensures that the streams are received without manipulation during transit.
We can achieve this by having an authenticated encryption scheme, such that we can verify that the data is coming from
the right participant and has not been tampered with. Alternatively, we can use digital signatures to verify the
integrity of the data.

We also want to make sure that the video and audio data is not modified by the server. This is a bit more difficult
since we need to trust the server to forward the video and audio data to the other participants. It is therefore crucial
that the server does not have access to the encryption keys, since this would allow the server to decrypt the data and
potentially modify it.

We consider the system integrity to be out of scope for this research. This means that we do not consider the
possibility that the server or the global client is compromised. This is a valid threat, but these are the same
assumptions
that are made in PubHubs.

\section{Availability}
Availability is the principle that information is available and accessible when needed by authorized individuals,
entities, or processes. In the context of PubHubs, this means that the video conferencing solution should be able to
handle numerous participants without compromising the functionality of the rest of PubHubs. We want the
video conferencing solution to be available to all users, but more importantly, we do not want a video call to slow
down the rest of PubHubs.

We saw previously that we can have a bottleneck when using P2P video conferencing, since every user needs to send
and receive more and more data with every new participant. This is not a scalable solution, and we will need to use
an SFU. These still have a limit on the number of participants, but this limit is based on the SFU servers resources.

This can be an attack vector, since an attacker can try to overload the hub server by creating many video
calls. We therefore need to have the possibility to have the SFU on a separate server as well as the possibility to
scale the SFU server horizontally. This means that we can deploy multiple SFU servers and have them work together.
This way, the load can be distributed over multiple (separate) servers, and not impact the rest of PubHubs.

\section{Authentication}
Authentication is the principle that the identity of a user can be verified. In the context of video conferencing,
this means that we should be able to verify that the person we are calling is who they say they are. In PubHubs, we
only have a pseudonym, which is a local identity for a particular hub. For some use cases this might be fine, however
for some use cases such as online consultations, we want to be sure that we are actually calling a doctor.

We could require certain attributes to be disclosed before a user can join a call. For example, a hub
can require that a user has a certain age before they can enter a call. These attributes can be the same for both
clients (symmetric) or it can be different attributes (asymmetric). For example, the doctor should disclose their medical
license, but the patient should only disclose their health registration number. We use Yivi to request and verify these
attributes.

While we could verify attributes when users enter a call, this might be redundant for secure rooms where users have
already disclosed their attributes. Since we have a one-to-one mapping between PubHubs rooms and Livekit rooms, we
can be sure that when the user is in the PubHubs room, they have already disclosed the required attributes. This way,
we can reuse code logic and have a more seamless experience for the user. The system could theoretically support
“temporary” secured rooms for one-time calls with specific attribute requirements, but this falls outside our current
research scope as implementation would be highly use-case dependent.

We might also want the possibility to verify additional attributes of the other users during the call ourselves. We also
consider this out-of-scope for this research, since this is a feature that is not present in PubHubs. For now, we trust
the server to verify the identity of the user.

\section{Design}
We want the video conferencing solution to be easy to use and understandable. It should also have the possibility of
some quality of life features that we come to expect from video conferencing solutions. We want to have basic
features like muting the microphone or the camera, seeing who is in the call, and sharing your screen. We also want
to have some more advanced features like noise suppression and video simulcast. These features are not strictly
necessary, but they can greatly improve the user experience \cite{skowronek_quality_2022}.
Fully implementing these features is out-of-scope for this research, but we want to have the possibility to implement
these features in the future.

PubHubs is a platform that is still under development and is constantly changing. This means that the video
conferencing solution should be able to adapt to these changes. PubHubs is also meant as a very configurable platform
where hubs can enable or disable certain features. This means that the video conferencing solution should be able to
be disabled without affecting the rest of PubHubs.

We can achieve this by having the video conferencing solution completely isolated from the rest of PubHubs.
This means that we will need to have a separate data store instead of extending the currently used data store.
Similarly, we will need to have separate endpoints which the video conferencing solution will use,
instead of extending the current endpoints. In general, we want to have a clear separation between the video conferencing
solution code and the rest of PubHubs.

\chapter{Proposed solution}
The proposed solution has multiple components. We will first discuss the new server setup, then the video conferencing
flow and lastly the encryption. We will also discuss the front end setup which is included in this prototype. We have
included a diagram which shows the different parts
and how they interact with each other.

In \autoref{fig:video-conference-setup}, the user is using the PubHubs client to join a room. In this figure, we can see
the hub docker container, which in our prototype consists of the hub server and the Livekit server (other services
are not depicted). The hub server is used to authenticate the user, after authentication, the hub server creates the
Livekit room and the results are sent to the user. After these steps, the call can begin. The users exchange keys
and finally join the call. In the figure, we can also see the contents of the \lstinline[language=js]{videoCall}
store, which is used in the hub client.

\begin{figure}[!hbt]
\centering
\includegraphics[width=1\textwidth]{img/PH_videocall.excalidraw.png}
\caption{Video conferencing setup}
\label{fig:video-conference-setup}
\end{figure}


\section{Server setup}\label{sec:server-setup}
The hub server needs some changes to be able to handle video conferencing. Firstly, we will now also need to deploy a
Livekit server instance. This Livekit server functions as an SFU and forwards all the video and audio traffic
between the different clients. This server does not see the video conferencing data since the data is end-to-end
encrypted and the server does not have access to the keys. The only thing that the Livekit server sees is the local
pseudonym of the user and other metadata (such as duration of the call, IP address of the user, etc.). The hub
server already knows this information, and thus this design does not leak additional data.

As mentioned previously, the Livekit server also has rooms, which we will map to the PubHubs rooms. We do this by
allowing only the hub server to create Livekit rooms. We do this by setting up the Livekit server with an API token,
which is known only by the hub server. We have set up a new endpoint on the hub server such that the user can
start a video call. The hub server will authenticate the user using the PubHubs authentication token and check if
the user is allowed to join the PubHubs room. If this is the case, the hub server will then create a room on the
Livekit server and return the room name to the user. If the Livekit room already exists, then the hub client will not
create a new room and instead will return the existing room name. This is the only way that a Livekit room can be created,
and it ensures that there is a one-to-one mapping between PubHubs rooms and Livekit rooms. Livekit rooms are automatically
deleted after a certain timeout period, which is started after the last user leaves the call.

The Livekit server uses a token for authentication of users, which is separate from the PubHubs authentication token.
This token is generated by the Livekit server but can be requested only by the hub server.
We have also created a new endpoint for this on the hub server. Similar to the previous endpoint, the hub server will
authenticate the user and check if the user is allowed to join the PubHubs room. The hub server will then request a
token from the Livekit server and return this token to the user. This token is valid only for the Livekit room and the
pseudonym, so the user cannot use this token to join another Livekit room or use another pseudonym.

Ideally, we would not have another token besides the PubHubs token, since if we would invalidate one of these two
tokens, we should probably also invalidate the other. Managing this can and will lead to problems later on. However,
having these two tokens allows us to have a separation between the hub server and the Livekit server. This way, we
can even host the Livekit server on a physically different server than the hub server, which would be beneficial for
the scalability of the system.

For the check whether a user is allowed to join a room, we use the same function that secured rooms use. Currently,
we only check if the user is allowed to join the PubHubs room, where the call is taking place. However, we can also
require the user to disclose certain YIVI attributes before we give them their token. This can easily be changed in the
future, since we can repurpose the code which is used to request YIVI attributes for secured rooms. For now, we consider
the inclusion of these attributes out-of-scope since we can have a similar result by allowing video conferencing
only in secured rooms, which have the required attributes.

The Livekit server can handle a lot of traffic, but when the hub is considerably large and has numerous video calls, it
might be a good idea to have a physically separate Livekit server. This way, the hub server will not be overloaded with
video traffic and can still serve the rest of the users. The Livekit server can also scale horizontally to handle
more traffic. This is simply a matter of deploying more Livekit servers and configuring them to work together.
Research has shown that the CPU utilization increases linearly based on the number of participants in a call
\cite{muscariello_securing_2023}. Using this, the hub can easily decide what number of users
they want to support and predict what server requirements they will need. Livekit also provides a CLI tool which
can give an indication what the maximum number of users is that the current server can handle.

To give some indication, a Livekit server running in a Google cloud compute instance with 16 cores
(c2-standard-16), has around 85 \% CPU utilization when 150 users with 720p video and audio are connected
\cite{noauthor_benchmarking_nodate}. The hub sever can also choose to completely outsource the Livekit server.
Livekit provides a paid service where they will host the Livekit server for you. This service scales
automatically, and the servers are distributed globally. This way the users will always have a proper low
latency connection to a Livekit server. This, however, is a tradeoff between privacy and ease of use. When using
the Livekit service, Livekit service will not have access to the video conferencing data, but they will have access to
the hub pseudonyms of the users and other metadata (such as duration of the call, IP address of the user, etc.). This
is a tradeoff that the hub server will have to make. PubHubs hosters could also offer a service where they host the
Livekit server and have different pricing tiers depending on the number of participants. This can become a potential
revenue stream for PubHubs.

\section{Video conferencing flow}
Our design also includes a video conferencing flow. The video conferencing flow describes the protocol and sequence
of steps that the clients (users) will follow to set up and join a video call.
This is a crucial part of the design, as it directly impacts the privacy and security of the video conferencing solution.
In the video conferencing flow, we deviate somewhat from the original Matrix specification. We follow the protocol
when setting up a call, but we do not implement the parts of the protocol which are used to manage the call. For
instance, in the protocol, the user shares their media devices and whether their devices are muted. We will not use
this since Livekit can handle this for us. We only need to know that a call has started in a room and the encryption
keys of the participants. Livekit will provide us with an endpoint where we can send and receive our data, which in
turn forwards it to the others in our room.

We will thus use the Matrix protocol only for setting up the room and sending the keys. This approach is also what
Matrix intends to do in the next version of element call, as they have specified in a presentation \cite{nirve_matrixrtc_nodate}. The
Matrix team now supports both solutions in their client SDK.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{img/Callflow.excalidraw.png}
\caption{The video conferencing flow}
\label{fig:video-conference-flow}
\end{figure}

To explain the flow, we will go through the flow of Alice starting a call with Bob.
When Alice wants to start a call with Bob, she will send a call event with an intent. This intent can be
everything from having the room automatically join to ringing the other participants. We did not implement
these different behaviors in the PubHubs client, since it was out-of-scope. After this, Alice's client will set up the
video conferencing screen, this is where she can choose her camera and microphone. When she is ready, Alice will
send her encryption keys and will send to the others that she is a member of the call. She will then wait for any
changes to the participants, if that happens, she will update her keys and send them to the others.

Bob will receive the call event and decides to join the call. His client will set up the video conferencing
screen where he can choose his camera and microphone. When he is ready, Bob will send his encryption keys and will
send to the others that he is a member of the call. Since Alice can see that there is a new participant, she will
update her keys and send them to Bob. Now that they have all the keys of all the participants, and they can decrypt
all the video and audio streams.

As you can see in \autoref{fig:video-conference-flow} Alice sent her keys twice, which is not strictly necessary,
however using this we can have a simple code base without having to check if the keys are already sent. The setup of
a call is now the same, regardless whether the call is new or already ongoing. This makes the code easier to
understand and maintain.

\section{Encryption}
For end-to-end encryption, we need to encrypt locally on the clients' device. For that, Livekit provides an e2ee worker,
which encrypts and decrypts incoming messages. This worker is a web worker, which is a separate
thread that runs in the background. This way, the main thread is not blocked by the encryption and decryption
process. The worker uses the Web Crypto API, which is a widely used and tested API for encryption and decryption.
The Web Crypto API is now supported in all modern browsers, so we can be sure that the encryption and decryption will
work on all devices.

Livekit uses Advanced Encryption Standard cipher in Galois/Counter Mode (AES-GCM)\cite{national_institute_of_standards_and_technology_us_advanced_2023}\cite{
mcgrew_galoiscounter_nodate}, to encrypt and authenticate the frames. This is a widely used and researched block
cipher. It is also very fast and efficient, even working well on slower devices.

The main problem at hand here is key management. For the encryption to work, we do need the keys from all
participants. To get these keys, we followed the Matrix specification. As of the writing, Matrix is in the middle
of transitioning to a new spec where the client can more directly request, revoke and rotate keys of the
participants. Although we believe this would be a better solution, we decided to stick with the current
implementation. This is because the new key management specification is not yet in the official Matrix specification.

The standard Matrix implementation distributes the keys by sending the keys as special messages in a Matrix room.
This is not ideal, since the keys are sent in the clear and can be read by the hub server. However, The hub
server is not in the Livekit room and thus does not have access to the video and audio data. This also prohibits us from
having forward secrecy since if you are in the room but not in the video conference, you can still read the keys from
before you joined the call.

Matrix has functionality to send these keys via private direct messages to the participants in the call. Bypassing
the hubs completely and thus preventing the hub from ever seeing the keys. However, this feature does not work yet 
with their new end-to-end encryption library. We have been in contact with the Matrix team, and they are working 
on this feature, so we decided to leave the code as is and wait for the new implementation. This means that until
we have the new implementation, we do not have perfect forward secrecy. As a temporary solution, we could create
a secured room for every call and only allow the participants in the call to join the room.

Whenever we are in a call, we subscribe to a \lstinline[language=js]{Matrix_RTC_Session}. This session handles
memberships and properties of a session. This will give us messages when a new user is added or when the keys are
updated. Whenever we get an updated key message from the \lstinline[language=js]{rtc_session}, we pass it through
our Livekit client, which in turn updates the keys and uses it for decryption. Although it is not implemented, users
can also rotate their keys. This is a feature that is supported by Livekit, but we did not implement it since it was
out-of-scope. Other complex key generation schemes are also possible and can very easily be implemented.

Since we need to initialize the Matrix crypto library for the encryption, we can very easily enable end-to-end
encryption for other messages in PubHubs. We have done some experiments with this, which we will discuss in \autoref{sec:encryption_of_messages}.

\section{The code and frontend}
\begin{figure}[!hbt]
\centering
\includegraphics[width=0.8\textwidth]{img/frontend.png}
\caption{A video call experiment with three participants. Each being the same individual (The author)}
\label{fig:front-end-setup}
\end{figure}
The code can be found in this github repository \cite{horst_gulianrdgdmaster-scriptie-pubhubs_2024}, it is a fork from the PubHubs
repository which includes the video conferencing solution. The frontend code is written in TypeScript and uses Vue 3
as the frontend framework. Styling is done using TailwindCSS. The backend code is written in Python and uses the
Python Livekit server package.

The video conferencing client is developed as an isolated component within PubHubs. This separation allows the
video conferencing solution to be toggled on or off using a feature flag.
This also means that the code is written in a way such that it is isolated from the rest of the PubHubs codebase.
We have a separate store for the video conferencing data, which is used only in the video conferencing code.
This store is used to store the call information, such as the room name, the participants, and the encryption keys.

The video conferencing code is written in the hub client code instead of the global client code. Having the code in
the hub client prevents the need to transmit sensitive data (e.g., room name, Livekit token, and the Livekit
server URL) to the global client, which could expose hub and room information to the global client unnecessarily.
This in turn could leak information about the hub to PHC, which we do not want.

This also has some other implications, namely that the hub can change the video conferencing solution.
This would enable the hub to adapt the video conferencing solution to their needs, such as requiring certain
attributes to be disclosed before joining a call. This could also lead to inconsistencies in the video conferencing
solution between different hubs, which could be confusing for the users. This is a tradeoff that was already made in
PubHubs, and the other features that run in the hub client have the same implications.

Having the video conferencing code inside the hub client means that it is inside the hub client Iframe.
This turned out to be a problem, when requesting the devices Camera and Microphone access. Because of security reasons, the
sandbox attribute is set on the Iframe. This means that the Iframe cannot request certain secure attributes.
Access to the camera and microphone are considered secure attributes.
To allow access without removing the iframe’s sandbox attribute, we opted to add the allow attribute and added
permissions for camera and microphone access.
This approach balances security with functionality by enabling device access without relaxing all sandbox restrictions.

Currently, the front end for the video conferencing client is simple and is responsive for up to 5 participants, after which
the video tiles will be cut off.
The primary focus was on back-end implementation, but we still developed a primitive interface which can be easily
extended in the future.
We followed PubHubs’ design principles and reused as many components as possible to ensure that the user interface
remains cohesive with the rest of the platform. Currently, little work in the backend is needed to make the video
conferencing client production-ready, but the frontend still needs some work. The frontend does not have any quality
of life features that we come to expect from modern video conferencing solutions. Features like muting the
microphone or the camera, seeing who is in the call, and sharing your screen are not yet implemented. The
infrastructure is in place to add these features, and adding these features should be relatively easy. This is
something that can be done in the future, but is out-of-scope for this research.

\chapter{Discussion}
The video conferencing solution proposed in this thesis aims to integrate confidential and secure authenticated video
calling into PubHubs while maintaining the platform's core principles of privacy, security, and usability. We evaluate
how well the solution meets the established requirements and analyze the key design decisions made during
implementation.

\section{Confidentiality}
The implementation achieves confidentiality through end-to-end encryption of video and audio streams using local
AES-GCM encryption. This ensures that the video conferencing content remains private, with only authorized
participants able to access the unencrypted streams. The SFU server, while handling the routing of encrypted
packets, cannot access the actual content of the calls since it does not have access to the keys. However, the current
key distribution mechanism represents a compromise in the implementation. Keys are sent as
clear-text Matrix room messages, which has two implications.

Firstly, the hub server can theoretically access these
keys. However, the hub server does not have access to the video and audio data, so for this to be a problem the hub
server would have to collude with the Livekit server. This is a serious tradeoff, but currently there is no end-to-end
encryption of regular messages in PubHubs. Therefore, the hub server can already see the messages of the users. Secondly,
the lack of perfect forward secrecy means that users who join a call late can decrypt the video and audio data from
before they joined. They would still have to collect the encrypted data, which is not trivial.

These limitations stem from Matrix's transitioning encryption library, which does not yet support end-to-end
encryption of direct messages. This is a temporary constraint and once they have implemented that, the
aforementioned implications should resolve itself. It does also not leak any more information than the hub server
already knows, and there is a tradeoff which should be considered but is not a critical issue. Despite these limitations,
the video and audio data is still secure when intercepted or leaked during transit. Since it is only a matter of time
before the new encryption library is implemented, we consider this to be implemented in the following sections of this
thesis. We do this to not repeat ourselves at every section, that we have this temporary limitation.

\section{Integrity}
The video conferencing solution maintains data integrity because of the use of AES-GCM encryption. This allows the
client to verify the integrity and authentication of additional authenticated data (AAD). When it comes to
authentication integrity, we do have a limitation, namely that the hub server knows the Livekit token of each user.
This could theoretically allow a malicious hub server to join calls and pretend to be a user. However, the hub
server cannot decrypt the video and audio data, since the keys are sent directly to the user and not via the hub server.

Again, this impersonation can already be done with the current implementation of PubHubs, since the hub server can
already pretend to be a user. The hub can change how a message is displayed and make it appear as if it was sent by
someone else. The hub itself can introduce changes to the hub client code, and PubHubs has no control over this.
This is a tradeoff that is already made in PubHubs, and the other features that run in the hub client have the same
implications.

\section{Availability}
In our video conferencing solution we use an SFU, this gives us great flexibility in terms of scalability. The
ability to deploy Livekit on separate servers and scale horizontally means that the solution can handle a large
number of participants without compromising the functionality of the rest of PubHubs. This is however up to the hub
to decide and configure, which should be made apparent to the hub administrators. The hub administrators should
calculate what an acceptable number of participants is and how many resources they are willing to allocate to the
video conferencing solution. Currently, this is a rather technical process, which could be made easier in the future
by providing some guidelines or even an automatic scaling solution.

A potential attack vector is that an attacker can try to overload the hub server by creating many video calls. This
is why we have the possibility to have the SFU on a separate server. When having the SFU on a different server, the hub
server will not be overloaded and only the video conferencing solution will be affected in the event of such an attack.
This does bring more complexity to the system, which an admin needs to manage. As mentioned previously, The hub server
can also choose to have the company Livekit host the Livekit server or a PubHubs hoster could provide a Livekit server as a service.

\section{Authentication}
The solution uses the same authentication mechanism as the rest of PubHubs. A user would need to authenticate with the
hub server before they receive a token for the Livekit server. Currently, we check only if the user is allowed to
join the room. This can be a regular room, a direct message room, or even a secured room. With the latter, we know
that the user has disclosed the required attributes to join the secured room. However, for some use cases, we might
want to have more control over who can join the call. For instance, when we do not want to allow all users in a
regular room to join a call. In direct messages rooms, we might want to have the user disclose their identity
before they can join the call, to make sure we are actually calling the right person and not an impersonator.

Although such a feature sounds reasonable, we would argue that this is not necessary, since you can have a similar
result by allowing video conferencing only in secured rooms. You would then set up these secured rooms with the
desired attributes and then start a call in those rooms. We believe that this is fine in most cases, since it would
not make sense to have a group call in a public room where you want to ensure that the participants have certain attributes.
The only setback is that you need to set up a secured room every time before you can start a call, but as long as the
attributes are not changed regularly you can reuse the same room.

\section{Privacy}
In our design we introduced a new server, the Livekit server. This server is used to forward the video and audio data
of the users, the server should not do anything else. Creating Livekit rooms and allowing users to join
those rooms is done by the hub server. The Livekit server and the hub server are controlled and managed by the hub
administrator. In our design, we made sure that the Livekit server does not learn more information about the users
than the hub server.

When a call is started, the Livekit server then knows the local pseudonym of the user and the room name. This is the
same information that the hub server already knows, so this does not leak any additional information. The Livekit server
does not have access to the video and audio data since it is encrypted and the server does not have access to the keys.
This is even one step further than the current implementation of PubHubs, since the hub server can see the messages of
the users as they are sent in plaintext.

Other than the technical aspect, it is also important to discuss privacy leakage that is inherent to video conferencing.
When communicating by video, users may inadvertently reveal personal information through their surroundings or
appearance. These small pieces of information can be used to identify or profile users \cite{kagan_zooming_2024},
even if for instance a virtual background is used \cite{hilgefort_spying_2021}. This is not something that can be
solved by the video conferencing solution, but should be handled by the users and the hub administrators. Hub admins
should make sure that the users are aware of this and should enable video conferencing only in certain rooms.

\chapter{Conclusion}
This research set out to design and implement a secure video conferencing solution for PubHubs. The proposed
solution integrates end-to-end encrypted authenticated video calling into the PubHubs platform while maintaining
the platform's core principles. We have designed and built a new server setup, which includes a Livekit server as an SFU.
This server forwards the video and audio data of users, while the hub server manages the video conferencing rooms
and user authentication. Additionally, this research defines a video conferencing flow that outlines the protocol
and sequence of steps users follow to set up and join a video call. The flow is designed to be simple and easy to
implement while ensuring security and privacy. We have set specific requirements and evaluated the proposed
solution against them.

The solution achieves confidentiality through end-to-end encryption of video and audio streams. Encryption is
performed locally in the browser using AES-GCM, a widely used and tested block cipher. We renew encryption keys
whenever a new participant joins the call, providing Forward Secrecy. Currently, keys are sent as clear-text
messages in a Matrix room instead of being sent directly to video call participants. This is a temporary
limitation, as the Matrix encryption library is expected to resolve this issue in future updates. Until then, the
hub server and other users in the room, even if not participating in the call, can theoretically access these keys.

In addition to confidentiality, the solution maintains data integrity by verifying that media streams are not
tampered with during transmission. This is achieved using AES-GCM’s authenticated encryption scheme. Authentication
integrity is maintained by leveraging PubHubs’ existing mechanism, which uses Yivi to request and verify user
attributes. In this prototype, we only verify if a user is allowed to join a room. Future iterations could enforce
more granular attribute-based access control by allowing video conferencing only in secured rooms configured with
the required attributes.

The solution also ensures availability for both the hub and the video conferencing service by using a separate SFU. This
allows the hub to host the video conferencing solution on a separate server and scale horizontally as needed. This
ensures that the hub server is not overloaded with video traffic and can continue to serve other PubHubs features.
The flexible setup also offers potential as a revenue stream for PubHubs.

The frontend implementation currently supports a limited number of participants and lacks advanced features like
screen sharing and muting. These features can be easily added in future iterations, but were out-of-scope for this
research.

Despite these limitations, this research demonstrates that a secure, scalable, and privacy-preserving video
conferencing solution can be successfully integrated into PubHubs. The solution aligns with the platform’s core
principles and provides a viable alternative to mainstream platforms. It is designed to be easily configurable and
adaptable to the needs of different hubs. This research lays the foundation for further development and refinement
of video conferencing in PubHubs and provides a robust framework for future work.

\chapter{Future work}
\section{Video conferencing use case for PubHubs}
The video conferencing solution proposed in this thesis is a generic solution that can be used in any hub. However,
there are some use cases where the video conferencing solution needs to be tailored to the specific needs of the hub.
For instance, some hubs might require the ability to schedule video calls, while others might need the ability to
record video calls. These are features that are not present in the current implementation, but can be added in the
future. The architectural design would not change, but some implementation details would. However, currently we do not
know what exactly the requirements are for these use cases. We would need to do requirements engineering to determine
what the hubs require. This is something that can be done in the future, but is out-of-scope for this research.

One of the specific use cases is speaker-to-audience video conferencing. As mentioned previously, we have three
types of video conferencing. We have only implemented the one-on-one type and the group type. However, there might
still be a need for speaker-to-audience type of video conferencing, for instance when a hub is owned by a
municipality, and they want to give a speech to their citizens. This type of video conferencing has different
requirements, and the current video conferencing setup would be inefficient.

We have a speaker who sends their video and audio stream to all the audience members. The audience members only send
their video and audio stream to the speaker. The latter is not even needed at all or for all members. This is not
achievable with the current setup, since we would need to send the video and audio stream to all the audience members.

Currently, it would be difficult to develop this feature without a clear use case, since depending on the use case we can
see what we can optimize. More research and requirements engineering is needed to build such a feature.

\section{End-to-end encryption for other messages}\label{sec:encryption_of_messages}
The current implementation encrypts only the video and audio data. In order to enable this, we need to initialize the
Matrix crypto library. This library can also be used to encrypt the other messages in PubHubs. We have experimented
with this and have found that it is straightforward to enable this. However, some PubHubs features did not work as expected
when we enabled this, such as sending images. This is something that is relatively easy to overcome, but more research is
needed to determine what the other implications are of enabling this feature.

There are also some considerations which need to be made before we can enable end-to-end encryption for other messages.
For instance, how would end-to-end encryption work with multiple devices? Currently, the encryption keys are stored in
the local storage of the browser. This means that when you switch devices, you will not have the encryption keys and
thus cannot decrypt the messages. Currently, PubHubs focuses on the web client, but in the future they might want to
have a mobile client be on par with the web client.

Another consideration is how to handle moderation (especially in video calls). One of the main features of PubHubs is
privacy-friendly moderation. However, when the messages are end-to-end encrypted, then the moderator also needs to have
access to the encryption keys \cite{noauthor_group_nodate}. This is currently not possible unless the moderator is in every
room/call. Future research needs to be done into PubHubs moderation and how this can be done with end-to-end encryption.

\newpage
\bibliographystyle{IEEEtran}
\bibliography{references.bib}

\end{document}